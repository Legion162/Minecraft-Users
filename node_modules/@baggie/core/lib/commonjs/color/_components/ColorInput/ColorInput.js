"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorInput = void 0;
var _react = _interopRequireWildcard(require("react"));
var _react2 = require("@baggie/react");
var _normalizeHexColor = require("../../convert/normalizeHexColor/normalizeHexColor");
var _convertColorNameToHex = require("../../convert/convertColorNameToHex/convertColorNameToHex");
var _isHexColor = require("../../check/isHexColor/isHexColor");
var _ColorInputModule = _interopRequireDefault(require("./ColorInput.module.scss"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const ColorInput = /*#__PURE__*/_react.default.forwardRef((props, ref) => {
  const [hasFocus, setHasFocus] = (0, _react.useState)(false);
  const {
    id,
    onChange,
    onBlur,
    onFocus,
    onKeyDown,
    value,
    label,
    labelRight,
    helperText,
    invalid,
    className,
    ...inputProps
  } = props;
  const autoId = (0, _react.useId)();
  const convertValue = (0, _react.useCallback)(() => {
    const trimmed = value.trim();
    const startsWithHash = trimmed.startsWith("#");
    if (!startsWithHash) {
      const hex = (0, _convertColorNameToHex.convertColorNameToHex)(trimmed) || `#${trimmed}`;
      if ((0, _isHexColor.isHexColor)(hex)) {
        onChange(hex);
      }
    }
  }, [onChange, value]);
  const handleOnKeyDown = (0, _react.useCallback)(event => {
    if (event.key === "Enter") {
      convertValue();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [convertValue, onKeyDown]);
  const handleOnFocus = (0, _react.useCallback)(event => {
    setHasFocus(true);
    if (onFocus) {
      onFocus(event);
    }
  }, [onFocus]);
  const handleOnBlur = (0, _react.useCallback)(event => {
    setHasFocus(false);
    convertValue();
    if (onBlur) {
      onBlur(event);
    }
  }, [convertValue, onBlur]);
  return /*#__PURE__*/_react.default.createElement(_react2.InputWrapper, {
    label: label,
    labelForId: id || autoId,
    labelRight: labelRight,
    helperText: helperText,
    invalid: invalid
  }, /*#__PURE__*/_react.default.createElement("input", _extends({
    ref: ref,
    id: id || autoId,
    value: value,
    onChange: _ref => {
      let {
        target
      } = _ref;
      return onChange(target.value);
    },
    onKeyDown: handleOnKeyDown,
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    className: [_ColorInputModule.default.textInput, className].join(" ").trim(),
    pattern: "^#((([0-9a-f]{3}){1,2})|(([0-9a-f]{4}){1,2}))$"
  }, inputProps)), /*#__PURE__*/_react.default.createElement("input", {
    type: "color",
    value: (0, _normalizeHexColor.normalizeHexColor)(value).substring(0, 7),
    onChange: _ref2 => {
      let {
        target
      } = _ref2;
      return onChange(target.value);
    },
    className: _ColorInputModule.default.colorInput,
    tabIndex: hasFocus ? undefined : -1
  }));
});
exports.ColorInput = ColorInput;
ColorInput.displayName = "ColorInput";
//# sourceMappingURL=ColorInput.js.map