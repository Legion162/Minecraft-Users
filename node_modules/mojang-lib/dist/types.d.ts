declare class Player {
    readonly uuid: string;
    readonly username: string;
    readonly properties: PlayerProperty[];
    constructor(data: PlayerIdentity);
}
type PlayerIdentity = {
    uuid?: string;
    id?: string;
    name: string;
    properties?: PlayerProperty[];
    demo?: boolean;
    legacy?: boolean;
};
type PlayerProperty = {
    name: string;
    value: string;
};

declare class RegularPlayerTextures {
    protected skin_url: any;
    protected cape_url: any;
    protected slim: boolean;
    protected uploadedAt: number;
    constructor(textureData: any);
    getAttributes: () => {
        skinURL: any;
        slim: boolean;
    };
    setAttributes: (slim: boolean, skinUrl: string) => void;
}

declare class RegularPlayer extends Player {
    readonly legacy: boolean;
    readonly demo: boolean;
    protected textures: RegularPlayerTextures;
    constructor(playerData: PlayerIdentity, logged?: boolean);
}

declare class MCAPI_PLAYERS {
    static get(username: string, raw?: boolean): Promise<RegularPlayer>;
    static getByUUID(uuid: string, raw?: boolean): Promise<RegularPlayer>;
    private static handleError;
}

declare class ServerPlayers {
    readonly max: number;
    readonly online: number;
    readonly list: Player[];
    constructor(data: ServerPlayerData);
}

declare class Server {
    #private;
    get host(): string;
    get port(): number;
    get icon(): string;
    get version(): string;
    get protocol(): number | NameVersion[];
    get players(): ServerPlayers;
    get title(): string;
    get motd(): ServerMotd;
    get online(): boolean;
    constructor(data: OnlineServer, host?: string, port?: number);
    refresh: () => Promise<void>;
}
type ServerMotd = {
    raw: string;
    formatted: string;
};
type NamesRaw = {
    names: string[];
    raw: string[];
};
type NameVersion = {
    name: string;
    version: string;
};
type RawCleanHtml = {
    raw: string[];
    clean: string[];
    html: string[];
};
type PingedServer = {
    online: boolean;
    ip: string;
    port: number;
    hostname?: string;
    debug: {
        ping: boolean;
        query: boolean;
        srv: boolean;
        queryMismatch: boolean;
        ipInSrv: boolean;
        cnameInSrv: boolean;
        animatedMotd: boolean;
        cacheHit: boolean;
        cacheTime: number;
        cacheExpire: number;
        apiVersion: number;
    };
};
type OnlineServer = PingedServer & ServerOptionals & {
    version: string;
    protocol: number | NameVersion[];
    icon?: string;
    map: string;
    gamemode?: string;
    serverId?: string;
    eulaBlocked?: boolean;
    motd: RawCleanHtml;
    players: ServerPlayerData;
};
type ServerOptionals = Partial<{
    software: string;
    plugins: NamesRaw | NameVersion[];
    mods: NamesRaw | NameVersion[];
    info: RawCleanHtml;
}>;
type ServerPlayerData = {
    online: number;
    max: number;
    list?: PlayerIdentity[];
    uuid?: {
        [key: string]: string;
    };
};

declare class MCAPI_SERVERS {
    static blockedServers: () => Promise<any>;
    static get: (host: string, port?: number) => Promise<Server>;
    static ping: (host: string, port?: number) => Promise<PingedServer | OnlineServer>;
}

declare class MCAPIError extends Error {
    readonly code: number;
    readonly date: Date;
    constructor(httpCode: number, ...params: any[]);
}

declare class MojangAccountProperties {
    readonly suspended: boolean;
    readonly blocked: boolean;
    readonly secured: boolean;
    readonly legacy: boolean;
    readonly migrated: boolean;
    readonly migratedUser: boolean;
    readonly hashed: boolean;
    readonly emailVerified: boolean;
    readonly parentVerified: boolean;
    constructor(data: any);
}

type AuthenticatedProfile = {
    name: string;
    id: string;
    legacy?: boolean;
};
type ProfileProperty = AuthenticatedProfile & {
    legacyProfile?: boolean;
    agent?: string;
    createdAt: string | number;
    tokenId?: string;
    suspended: boolean;
    migrated: boolean;
};
declare class GameProfile {
    readonly account: any;
    readonly created: Date;
    readonly game: string;
    readonly uuid: string | number;
    readonly username: string;
    readonly token: string;
    constructor(data: ProfileProperty, associated_account: any);
}

declare class MojangAccountProfiles {
    readonly list: GameProfile[];
    readonly selected: GameProfile;
    constructor(data: MojangAccountData, associated_account: any);
}

declare class MojangAccount {
    readonly tokens: {
        access: string;
        client: string;
    };
    readonly registration: AccountRegistration;
    readonly account_id: string;
    readonly username: string;
    readonly email: string;
    readonly properties: MojangAccountProperties;
    readonly profiles: MojangAccountProfiles;
    constructor(data: MojangAccountData);
}
type UserProperty = {
    name: string;
    value: string;
};
type AccountRegistration = {
    ip: string;
    date: Date;
};
type MojangAccountData = {
    clientToken: string;
    accessToken: string;
    user: {
        username: string;
        properties: UserProperty[];
        id: string;
        email?: string;
        registerIp?: string;
        registeredAt?: string | number;
    };
    availableProfiles: ProfileProperty[];
    selectedProfile: ProfileProperty;
};

declare class MCAPI_ACCOUNTS {
    loadAll: boolean;
    static get loadAll(): boolean;
    static set loadAll(value: boolean);
    static login(identity: string, password: string): Promise<MCAPIError | MojangAccount>;
}

declare class MCAPI {
    static readonly accounts: typeof MCAPI_ACCOUNTS;
    static readonly players: typeof MCAPI_PLAYERS;
    static readonly servers: typeof MCAPI_SERVERS;
    static get version(): string;
}

export { MCAPI, MCAPI_ACCOUNTS as accounts, MCAPI as default, MCAPI_PLAYERS as players, MCAPI_SERVERS as servers };
